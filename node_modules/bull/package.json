{
  "name": "bull",
  "version": "0.1.6",
  "description": "Job manager",
  "main": "index.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/OptimalBits/bull.git"
  },
  "keywords": [
    "job",
    "queue",
    "task",
    "parallel"
  ],
  "author": {
    "name": "OptimalBits"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "dependencies": {
    "redis": "~0.8.4",
    "when": "~2.1.1",
    "lodash": "~2.2.1",
    "bluebird": "~1.0.1",
    "node-uuid": "~1.4.1"
  },
  "devDependencies": {
    "mocha": "~1.12",
    "expect.js": "~0.2.0"
  },
  "scripts": {
    "test": "mocha test/* --reporter spec"
  },
  "readme": "Bull Job Manager\n================\n\n![bull](http://files.softicons.com/download/animal-icons/animal-icons-by-martin-berube/png/128/bull.png)\n\nA lightweight, robust and fast job processing queue.\nDesigned with stability and atomicity in mind. The API is inspired by Kue.\n\nIt uses redis for persistence, so the queue is not lost if the server goes\ndown for any reason.\n\nIf you need more features than the ones provided by Bull check\n[Kue](https://github.com/learnboost/kue) but keep in mind this open\n[issue](https://github.com/LearnBoost/kue/issues/130).\n\n[![BuildStatus](https://secure.travis-ci.org/OptimalBits/bull.png?branch=master)](http://travis-ci.org/OptimalBits/bull)\n\nFollow [manast](http://twitter.com/manast) for news and updates regarding this library.\n\nInstall:\n--------\n\n    npm install bull\n\nNote that you need a redis version higher or equal than 2.6.12 for bull to work.\n\nQuick Guide\n-----------\n```javascript\nvar Queue = require('bull');\n\nvar videoQueue = Queue('video transcoding', 6379, '127.0.0.1');\nvar audioQueue = Queue('audio transcoding', 6379, '127.0.0.1');\nvar imageQueue = Queue('image transcoding', 6379, '127.0.0.1');\n\nvideoQueue.process(function(job, done){\n\n  // job.data contains the custom data passed when the job was created\n  // job.jobId contains id of this job.\n\n  // transcode video asynchronously and report progress\n  job.progress(42);\n\n  // call done when finished\n  done();\n\n  // or give a error if error\n  done(Error('error transcoding'));\n\n  // If the job throws an unhandled exception it is also handled correctly\n  throw (Error('some unexpected error'));\n});\n\naudioQueue.process(function(job, done){\n  // transcode audio asynchronously and report progress\n  job.progress(42);\n\n  // call done when finished\n  done();\n\n  // or give a error if error\n  done(Error('error transcoding'));\n\n  // If the job throws an unhandled exception it is also handled correctly\n  throw (Error('some unexpected error'));\n});\n\nimageQueue.process(function(job, done){\n  // transcode image asynchronously and report progress\n  job.progress(42);\n\n  // call done when finished\n  done();\n\n  // or give a error if error\n  done(Error('error transcoding'));\n\n  // If the job throws an unhandled exception it is also handled correctly\n  throw (Error('some unexpected error'));\n});\n\nvideoQueue.add({video: 'http://example.com/video1.mov'});\naudioQueue.add({audio: 'http://example.com/audio1.mp3'});\nimageQueue.add({image: 'http://example.com/image1.tiff'});\n```\n\nA queue can be paused and resumed:\n```javascript\nqueue.pause().then(function(){\n  // queue is paused now\n});\n\nqueue.resume().then(function(){\n  // queue is resumed now\n})\n```\n\nA queue emits also some useful events:\n```javascript\nqueue.on('completed', function(job){\n  // Job completed!\n})\n.on('failed', function(job, err){\n  // Job failed with reason err!\n})\n.on('progress', function(job, progress){\n  // Job progress updated!\n})\n.on('paused', function(){\n  // The queue has been paused\n})\n.on('resumed', function(job){\n  // The queue has been resumed\n})\n```\n\nQueues are cheap, so if you need many of them just create new ones with different\nnames:\n```javascript\nvar userJohn = Queue('john');\nvar userLisa = Queue('lisa');\n.\n.\n.\n```\n\nQueues are robust and can be run in parallel in several threads or processes\nwithout any risk of hazards or queue corruption. Check this simple example\nusing cluster to parallelize jobs accross processes:\n```javascript\nvar\n  Queue = require('bull'),\n  cluster = require('cluster');\n\nvar numWorkers = 8;\nvar queue = Queue(\"test concurrent queue\", 6379, '127.0.0.1');\n\nif(cluster.isMaster){\n  for (var i = 0; i < numWorkers; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('online', function(worker) {\n    // Lets create a few jobs for the queue workers\n    for(var i=0; i<500; i++){\n      queue.add({foo: 'bar'});\n    };\n  });\n\n  cluster.on('exit', function(worker, code, signal) {\n    console.log('worker ' + worker.process.pid + ' died');\n  });\n}else{\n  queue.process(function(job, jobDone){\n    console.log(\"Job done by worker\", cluster.worker.id, job.jobId);\n    jobDone();\n  });\n}\n```\n\nUseful patterns\n---------------\n\n####Message Queue\n\nBull can also be used for persistent messsage queues. This is a quite useful\nfeature in some usecases. For example, you can have two servers that need to\ncommunicate with each other. By using a queue the servers do not need to be online\nat the same time, this create a very robust communication channel:\n\n```javascript\nvar Queue = require('bull');\n\n// If we are server one, we will use queueOne for sending and queue two for\n// receiving.\n\nvar sendQueue = Queue(\"server one message queue\", 6379, '127.0.0.1');\nvar receiveQueue = Queue(\"server two message queue\", 6379, '127.0.0.1');\n\n// we can send any JSON stringfiable data\nsendQueue.add({msg: 'this is a test message'});\n\n// And receive as well\nreceiveQueue.process(function(msg, msgDone){\n  console.log('Received message from server two: %s', msg);\n  msgDone();\n});\n```\n\n####Returning job completions\n\nA common pattern is where you have a cluster of queue processors that just\nprocess jobs as fast as they can, and some other services that need to take the\nresult of this processors and do something with it, maybe storing results in a\ndatabase.\n\nThe most robust and scalable way to accomplish this is by combining the standard\njob queue with the message queue pattern: a service sends jobs to the cluster\njust by opening a job queue and adding jobs to it, the cluster will start\nprocessing as fast as it can. Everytime a job gets completed in the cluster a\nmessage is send to a results message queue with the result data, this queue is\nlistened by some other service that stores the results in a database.\n\n\n##Documentation\n\n* [Queue](#queue)\n* [Queue##process](#process)\n* [Queue##add](#add)\n* [Queue##count](#count)\n* [Queue##empty](#empty)\n* [Job](#job)\n* [Job##remove](#remove)\n\n\n## Reference\n\n<a name=\"queue\"/>\n###Queue(queueName, redisPort, redisHost, [redisOpts])\n\nThis is the Queue constructor. It creates a new Queue that is persisted in\nRedis. Everytime the same queue is instantiated it tries to process all the\nold jobs that may exist from a previous unfinished session.\n\n__Arguments__\n\n```javascript\n    queueName {String} A unique name for this Queue.\n    redisPort {Number} A port where redis server is running.\n    redisHost {String} A host specified as IP or domain where redis is running.\n    redisOptions {Object} Optional options to pass to the redis client.\n```\n\n---------------------------------------\n\n\n<a name=\"process\"/>\n#### Queue##process(function(job, done))\n\nDefines a processing function for the jobs placed into a given Queue.\n\nThe callback is called everytime a job is placed in the queue and\nprovides an instance of the job and a done callback to be called after the\njob has been completed. If done can be called providing an Error instsance\nto signal that the job did not complete successfully.\n\n__Arguments__\n\n```javascript\n    jobName {String} A job type name.\n    cb {Function} A callback called for every job of the given name.\n```\n\n---------------------------------------\n\n<a name=\"add\"/>\n#### Queue##add(data, opts)\n\nCreates a new job and adds it to the queue. If the queue is empty the job\nwill be executed directly, otherwise it will be placed in the queue and\nexecuted as soon as possible.\n\n__Arguments__\n\n```javascript\n  data {PlainObject} A plain object with arguments that will be passed\n    to the job processing function in job.data.\n  opts {PlainObject} A plain object with arguments that will be passed\n    to the job processing function in job.opts\n  opts.lifo {Boolean} A boolean which, if true, adds the job to the right\n    of the queue instead of the left (default false)\n  returns {Promise} A promise that resolves when the job has been succesfully\n    added to the queue (or rejects if some error occured).\n```\n\n---------------------------------------\n\n\n<a name=\"count\"/>\n#### Queue##count()\n\nReturns a promise that returns the number of jobs in the queue, waiting or\npaused. Since there may be other processes adding or processing jobs, this\nvalue may be true only for a very small amount of time.\n\n__Arguments__\n\n```javascript\n  returns {Promise} A promise that resolves with the current jobs count.\n```\n\n---------------------------------------\n\n<a name=\"empty\"/>\n#### Queue##empty()\n\nEmpties a queue deleting all the input lists and associated jobs.\n\n__Arguments__\n\n```javascript\n  returns {Promise} A promise that resolves with the queue is emptied.\n```\n\n---------------------------------------\n\n<a name=\"job\"/>\n### Job\n\nA job includes all data needed to perform its execution, as well as the progress\nmethod needed to update its progress.\n\nThe most important property for the user is Job##data that includes the\nobject that was passed to Queue##add, and that is normally used to\nperform the job.\n\n---------------------------------------\n\n<a name=\"remove\"/>\n#### Job##remove()\n\nRemoves a Job from the queue from all the lists where it may be included.\n\n__Arguments__\n\n```javascript\n  returns {Promise} A promise that resolves when the job is removed.\n```\n\n---------------------------------------\n\n\n##License\n\n(The MIT License)\n\nCopyright (c) 2013 Manuel Astudillo <manuel@optimalbits.com>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n",
  "bugs": {
    "url": "https://github.com/OptimalBits/bull/issues"
  },
  "homepage": "https://github.com/OptimalBits/bull",
  "_id": "bull@0.1.6",
  "_from": "bull@*"
}
